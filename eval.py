#!/usr/bin/env python
# -*- coding: utf-8 -*-

# -----------------------------------------------------------------------
# eval.py
# Verification in Python code
#
# Creation Date   : 04/Aug./2017
# Copyright (C) <2017> Hiroki Nakahara, All rights reserved.
#
# Released under the GPL v2.0 License.
#
# Acknowledgements:
# This source code is based on following projects:
#
# Chainer binarized neural network by Daisuke Okanohara
# https://github.com/hillbig/binary_net
# Various CNN models including Deep Residual Networks (ResNet)
#  for CIFAR10 with Chainer by mitmul
# https://github.com/mitmul/chainer-cifar10
# -----------------------------------------------------------------------

import argparse
import os
import _pickle as pickle # python 3.5
import numpy as np
import cv2
from chainer import Variable
from chainer import serializers
import net3 # it will be generated by the GUINNESS

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description = "Evaluation Python Code"
    )
    parser.add_argument(
        '--count',
        type = int,
        default = 10,
        help = "Number of Tests"
    )
    parser.add_argument(
        '--export',
        '-e',
        type = str,
        default='no',
        help = "Export Test Images"
    )
    parser.add_argument(
        '--model',
        '-m',
        type = str,
        default = 'temp.model',
        help = "Pre-Trained Model Name"
    )
    parser.add_argument(
        '--dataset',
        '-d',
        type = str,
        default='../none',
        help = "Dataset Image pkl File Path Prefix"
    )
    parser.add_argument(
        '--size',
        '-s',
        type = int,
        default = 32,
        help = "Test Image Size"
    )
    parser.add_argument(
        '--view',
        '-v',
        type = str,
        default='yes',
        help = "Show Test Image"
    )
    args = parser.parse_args()

    print("Loading dataset...")
    fname = args.dataset + '_dataset.pkl'
    with open(fname, 'rb') as f:
        images = pickle.load(f)
        test_x = images['test'].astype(np.float32)

    fname = args.dataset + '_label.pkl'
    with open(fname, 'rb') as f:
        labels = pickle.load(f)
        test_y = labels['test'].astype(np.int32)

    n_test_x = len(test_x)
    print("%d test images were loaded." % (n_test_x))

    print("Start evaluation")

    net = net3.CNN()
    print("Loading pre-trained npz...")
    serializers.load_npz(args.model, net)

    # set image size
    img_siz = args.size

    eval_x = np.ones((1, 3, img_siz, img_siz))

    # load tag file
    name = []
    fname = args.dataset + '_tag.txt' # tag file be generated by 'gen_training_data.py'
    with open(fname, 'r') as f:
        lines = f.readlines()
        for line in lines:
            name.append(line.rstrip('\n\r'))

    n_class = len(name)

    conf_matrix = np.zeros((n_class, n_class))

    # specify the number of tests
    n_tests = args.count
    if n_tests > n_test_x:
        n_tests = n_test_x
    n_acc = 0

    # perform test
    image = test_x
    image = image.clip(0, 255).astype(np.uint8)
    for idx in range(0, n_tests):
        # Note that, the test image is generated by the OpenCV, thus, its format consists of 'BGR' not 'RGB'
        image1 = image[idx].reshape(3, img_siz, img_siz).transpose(1, 2, 0)

        # generate test bench
        # for C/C++ simulation in the Vivado HLS, and an FPGA board
        if args.export == 'yes':
            bench_img = image1.reshape(-1,)
            fname = 'test_img_%d.txt' % idx # + str(idx) + '.txt'
            print("[%d/%d] Exporting the test image..." % (idx + 1, n_tests))
            np.savetxt(fname, bench_img, fmt = "%.0f", delimiter = ",")

        eval_x[0, :, :, :] = test_x[idx] #/ 256.0

        result = net(Variable(eval_x.astype(np.float32)), train = False)
        print(result.data)
        print("[%d/%d] label/result = %s/%s" % (idx + 1, n_tests, name[test_y[idx]], name[result.data.argmax()]))

        # regist a confusion matrix
        conf_matrix[test_y[idx], result.data.argmax()] = conf_matrix[test_y[idx], result.data.argmax()] + 1

        if test_y[idx] == result.data.argmax():
            n_acc = n_acc + 1
        else:
            print("[%d/%d] Unmatch!" % (idx + 1, n_tests))

        # show test image
        if args.view == 'yes':
            cv2.imshow("Test Image", image1)
            cv2.waitKey(0)

    if args.view == 'yes':
        cv2.destroyAllWindows()

    # show a confusion matrix
    print("Confusion Matrix")
    print(conf_matrix.astype(np.int32))
    print("# corrests = %d" % n_acc)
    print("Accuracy = %f" % (float(n_acc) / n_tests))
